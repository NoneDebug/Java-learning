# 类与对象

- 问题来源：
	- 利用单独变量管理猫的信息不利于数据管理
	- 利用数组，数据类型不好管理，效率低

- 故采用类和对象管理一个对象的属性或行为信息

- 类与对象的概念
	- 类是对对象的抽象，对所有对象共有属性和行为进行统一的一个玩意
	- 比如，人是一个类（包括年龄、性别等属性），然后该类的一个具体对象可以是名为“李明” 的 男性对象。
	- 对象的创建步骤为：1. 创建一个类（规范化属性 + 行为） 2. 实例化一个对象 3.把类实例化

- 类和对象的区别和联系
	- 类是抽象的，概念的，代表一类食物，比如人类，猫类..，即它是数据类型。
	- 对象是具体的，实际的，代表一个具体事物，即 实例。
	- 类是对象的模板，对象是类的一个个体，对应一个实例。

## 对象在内存中存在形式

- 具体实例：

```
Cat cat = new Cat();
cat.name = "小白"
cat.age = 12;
cat.color = "白色";

public class Cat{
	String name;
	int age;
	String color;
}
```

- JVM内存管理区
	- **栈区：**`cat`对象地址存放在此处，指向堆区的三个属性存放的首地址，三个属性连续存放
	- **堆区：**
		- 对于`name`属性，因其是`String`对象，故在堆区存放一个地址，该地址指向方法区中的一块内存，该内存存放对应的具体数值
		- 对于`age`属性，因其是`int`类型，非对象，故对应该区直接存放年龄`12`
		- 对于`color`属性，因其是`String`对象，同
	- **方法区：**
		- 对于堆区中`name`属性指向的内存区，存放`"小白"`字符串
		- 对于堆区中`color`属性指向的内存区，存放`"白色"`字符串

## 属性/成员变量

- 概念：属性 = 成员变量 = field(字段)
- 属性是类的一个组成部分，一般是基本数据类型，也可是引用类型(对象，数组)。


## 属性注意事项和细节

- 属性的定义语法同变量，访问修饰符(public, protected, private) 属性类型 属性名
	- 访问修饰符有4种：public, protected, 默认, private
	-  `Person p1 = new Person()`中，`p1`是对象名（对象引用），`new Person()`创建的对象空间（数据）才是真正的对象
- 属性的定义类型可以为任意类型，包含基本类型或引用类型
	- `String`就是引用类型，`int,double`等即为基本类型
- 属性如果不赋值，有默认，规则和数组一致

## 如何创建对象

- 方法1：先声明再创建
	```Cat cat;    cat = new Cat();```
- 方法2：直接创建
	`Cat cat = new Cat();`

## 如何访问属性

`对象名.属性名`

## 类和对象的分配机制（重要）

```
Person p1 = new Person();
p1.age = 10;
p1.name = "小明";
Person p2 = p1;
System.out.println(p2.age);
//问 p2.age输出是多少
//答 10
```

- 从上例看出 在栈区，p2 指向了 p1

- 相关机制总结：
	- 栈：一般存放基本数据类型（局部变量）
	- 堆：存放对象（Cat cat, 数组等）
	- 方法区：常量池（常量，比如字符串），类加载信息

# 成员方法

- 基本介绍
	- 定义成员方法（简称方法）。比如人类：除了有一些属性外(年龄，姓名..)，人类还有一些行为：可以说话、跑步..，通过学习，还可以做算数题，可以采用成员方法来完成

## 成员方法传参机制

- 以`getSum`方法为例讲解 **方法** 的运行机制（代码如下）
	- JVM内存分析
		- 栈区：从`main`开始，称为`main栈`，当执行`Person p1`时，创建一个名为`p1`的`Person`对象，未分配空间。接着`p1 = new Person()`语句表示为`p1`在堆区创建一个`Person`对象，为其分配空间。然后`int resNum = p1.getSum(23, 33);`语句调用`p1`的`getSum`方法，首先通过栈区再开辟一个新栈，为`getSum`栈，然后跳转执行`getSum`内语句，求和并返回。释放`getSum`栈区。
		- 堆区：`p1 = new Person()`语句表示为`p1`在堆区分配一个空间。
```
public class xxx{
	public static void main(String[] args){
		Person p1;   //创建一个名为p1的Person对象
		p1 = new Person();   //实例化此对象，即为其分配空间
		int resNum = p1.getSum(23, 33);
		System.out.println("getSum方法返回的值=" + returnRes);
	}
}
class Person{
	int age;
	String name;
	public int getSum(int num1, int num2){
		int res = num + num2;
		return res;
	}
}
```

- 方法的妙用
	- 封装函数能够提高代码的复用性
	- 将实现的细节封装起来，供其它用户调用即可

- 成员方法语法

``` 
public 返回数据类型 方法名 (参数列表..){
	//方法体语句;
	return 返回值;
}
1. 参数列表：表示成员方法输入 cal(int n)
2. 数据类型（返回类型）：表示成员方法输出，void表示没有返回值
3. 方法主体：表示为了实现某一功能代码块
4. return语句不是必须的
```

## 方法使用细节

- pubic属于一种访问修饰符，控制方法使用的范围
	- 有四种：public, protected, 默认, private

- 返回数据类型
	- 一个方法最多有一个返回值
		- 实现返回多个结果：返回数组的形式
	- 返回类型可以为任何类型
	- 方法要求必须要有返回数据类型，则最后执行语句必须为return值，且数据类型一致 或 **兼容**
	- 如果方法是void，则方法体中可以没有return语句，或者只写 `return;`
	- 方法名：采用驼峰命名法，见名知意

- 形参列表
	- 方法可以有0个，也可以有多个参数，中间用逗号隔开
	- 参数类型可以为任意类型
	- 调用带参数方法时，一定对应参数列表传入同类型或者兼容类型的参数
	- 方法定义的参数称为形式参数，简称形参；方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致

- 方法体
	- 里面写完功能的具体语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但不能再定义方法（即方法不能嵌套）。

- 方法细节调用说明
	- 同一个类中的方法调用：直接调用（方法1调用方法2）
	- 跨类中A类调用B类方法，需通过对象名调用（A的方法1调用B的方法2等）
	- 跨类的方法调用和方法的访问修饰符相关。

## 方法传参机制

### 基本数据类型的传参机制

```
//示例
public void swap(int a, int b){
	int tmp = a;
	a = b;
	b = temp;
	System.out.println("a="+a+"\tb=" + b);
}
```
- 只是通过值传递，而非引用传递，若不同方法的引用，则不会引起值的交换。
- 结论：基本数据类型，传递的是值（值拷贝），形参的任何改变不会影响实参

### 引用数据类型的传参机制

- 引用类型传递的是地址（传递也是值，但是值的含义是地址），可以通过形参影响实参


## 方法的递归调用

- 定义：方法调用自己，每次调用时传入不同的变量，有利于解决复杂问题，让代码更加简洁

### 递归重要规则

- 执行方法时，就创建一个新的受保护的独立空间（栈空间）
- 方法的局部变量是独立的，不会相互影响，比如n变量
- 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据
- 递归必须向退出的递归的条件逼近，否则出现无限递归，即StakOverflowFError
- 一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，谁将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### 实例：迷宫问题

```
public class MAZE{
	public static void main(String[] args){
		//1. 先创建迷宫，用二维数组表示 例 int[][] map = new int[8][7];
		//2. 先规定map数组的元素值：0表示可以可走 1表示有障碍
		int[][] map = new int[8][7];
		//将最上面的一行 和 最下面一行置为1
		for(int i = 0; i < 7; i++){
			map[0][i] = 1;
			map[7][i] = 1;
		}
		//将最左边一列 和 最右边一列置为1
		for(int j = 1; j < 7; j++){
			map[j][0] = 1;
			map[j][6] = 1;
		}
		map[3][1] = 1;
		map[3][2] = 1;
		System.out.println("====================");
		for(int i = 0; i < map.length; i++){
			for(int j = 0; j < map[i].length; j++){
				System.out.print(map[i][j] + " ");
			}
			System.out.println();
		}
		System.out.println("====================");
		T t1 = new T();
		t1.findWay(map, 1, 1);
		for(int i = 0; i < map.length; i++){
			for(int j = 0; j < map[i].length; j++){
				System.out.print(map[i][j] + " ");
			}
			System.out.println();
		}
	}
}
class T{

	//使用递归回溯的思想来解决老鼠出迷宫
	//1. findWay方法是专门来找出迷宫的路径
	//2. 找到，返回true，反之返回false
	//3. map表示二维数组，即迷宫
	//4. i,j 表示老鼠位置，初始化位置为(1,1)
	//5. 因为是递归的找路，所以先规定 map数组的各个值的含义
	// 	0 表示可以走 1 表示障碍物 2 表示可以走 3 表示走过，但是走不动
	//6. 当map[6][5] = 2时，说明找到通路，否则继续找
	//7. 先确定找路策略 下->右->上->左
	public boolean findWay(int[][] map, int i, int j){

		if(map[6][5] == 2){
			return true;
		}else{
			if(map[i][j] == 0){
				//假定可以走通
				map[i][j] = 2;
				//下->右->上->左
				if(findWay(map, i + 1, j)){
					return true;
				}else if(findWay(map, i, j + 1)){
					return true;
				}else if(findWay(map, i - 1, j)){
					return true;
				}else if(findWay(map, i, j - 1)){
					return true;
				}else{
					map[i][j] = 3;
					return false;
				}
			}else{
				return false;
			}
		}
	}
}
```

- 可以修改找路策略，会影响输出路径

# 重载(overload)

- 基本介绍
	- Java允许同一个类，多个同名方法的存在，但是形参列表不一致

- 重载的好处
	- 减轻起名的麻烦
	- 减轻记名的麻烦

- 语法（一个例子）

```
class MyCalculator{

	public int calculate(int n1, int n2){
		return n1 + n2;
	}
	public double calculate(int n1, double n2){
		return n1 + n2;
	}
	public double calculate(double n1, int n2){
		return n1 + n2;
	}
	public int calculate(int n1, int n2, int n3){
		return n1 + n2 + n3;
	}
}
```

- 使用细节
	- 方法名必须相同
	- 形参列表必须不同，形参数量或者顺序至少有一样不同，参数名无要求
	- 返回类型不同，即使形参列表相同，也不能称为重载


# 可变参数

- 基本概念：Java允许将同一个类中多个同名同功能但参数不同的方法，封装成一个方法
- 基本语法：`访问修饰符 返回类型 方法名(数据类型...形参名){}`
- `...`：表示接收的是可变参数，类型是`int`，可接收多个（0~多个）

### 注意事项和使用细节

- 可变参数的实参可以为0个或任意多个
- 可变参数的实参可以为数组
- 可变参数的本质是数组
- 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
- 一个形参列表中只能出现一个可变参数
	- `public void f3(int... nums1, double ... nums2){} //  该语句是错误的`


# 作用域

- 介绍
	- Java编程中，主要的变量就是属性（成员变量）和局部变量
	- 我们所说的局部变量一般指在成员方法中定义的变量
	- Java中作用域的分类
		- 全局变量：属性，作用域为整个类
		- 局部变量：除了属性之外的其它变量，作用域为定义它的代码块
	- 全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，没有默认值。

```
class Cat{
	int age = 10;//全局变量
	public void cry(){
		int n = 10;
		String name = "jack";
	}
	public void eat(){
		System.out.println("在eat中使用属性 age = " + age);
	}
}
```

### 注意事项和使用细节

- 属性和局部变量可以重名，访问时遵循就近原则
- 同一作用域中，在同一个成员方法中，两个局部变量不能重名
- 属性声明周期短，伴随对象的创建而创建，伴随对象的死亡而死亡。局部变量生命周期短，伴随代码块的执行二创建，伴随代码块的结束而死亡，在一次方法调用过程中。
- 作用域范围不同
	- 全局变量：可以被本类使用，或其他类使用（通过对象调用）
	- 局部变量：仅能在本类中对应方法中使用
- 修饰符不同
	- 全局变量/属性：可以加修饰符
	- 局部变量：不可以加修饰符

# 构造器

- 需求：创建对象时，同时指定初始化此对象的一些属性，可使用构造器
- 基本语法：`[修饰符] 方法名(形参列表){方法体}`
	- 构造器的修饰符可以默认
	- 构造器没有返回值
	- 方法名 和 类名必须一样
	- 参数列表 和 成员方法一样的规则
	- 构造器的调用由系统完成

### 注意事项和使用细节

- 一个类可以定义多个不同的构造器，即构造器重载
- 构造器名和类名要相同
- 构造器没有返回值
- 构造器是完成对象的初始化，而不是创建对象
- 在创建对象时，系统自动地调用该类的构造方法
- 如果程序员没有定义构造方法，系统会自动给类生成一个无参构造方法（也叫默认构造方法），比如`Person(){}`。
	- 反编译：`javap xxx.class`，可以观察类的等价构造代码
- 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式地定义一下。

# this

- 什么是this：java虚拟机给每个对象分配this，代表当前对象。
- 语法：`this.属性名`

### this的使用细节

- this关键字可以访问本类的属性、方法、构造器
- this用于区分当前类的属性和局部变量
- 访问成员方法的语法：`this.方法名(参数列表)`
- 访问构造器语法：`this(参数列表);` 注意只能在构造器中使用（只能在一个构造器中调用另一个构造器），且只能放在第一条语句。
- this不能在类定义的外部使用，只能在类定义的方法中使用

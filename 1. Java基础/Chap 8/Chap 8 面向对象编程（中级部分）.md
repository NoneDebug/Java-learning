# 包

- **问题来源**：两个程序员共同开发一个java项目，程序员1希望定义一个类，取名为Dog，程序员2也希望定义一个类叫Dog，应该如何解决。

## 包的作用

- 区分相同名字的类
- 当类很多时，可以很好地管理类（通过查阅Java API文档）
- 控制访问范围

## 包的基本语法

- `package xxx.xxx`
- 解释：`package` 是关键字，表示打包；`xxx.xxx` 表示包名

## 包的本质分析（原理）

- 实际上是创建不同的文件夹保存类文件，画出示意图

## 包的命名

- 命名规则
	- 只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字
		e.g. `demo.class.exec1` , `demo.12a`, `demo.ab12.oa`

- 命名规范
	- 一般是小写字母 + 小圆点 ：
		- com.公司名.项目名.业务模块名
			- 比如：`com.hspedu.oa.model`; `com.hspedu.oa.controller`
		- 举例
			- `com.sina.crm.user  //用户模块`
			- `com.sina.crm.order  //订单模块`
			- `com.sina.crm.utils   //工具类`

- 常用的包
	- 一个包类，包含很多的类，java常用的包有：
		- java.lang.*   //lang包是基本包，默认引入，不需要再引入
		- java.util.*     //util包，系统提供的工具包，工具类，使用Scanner
		- java.net.*     //网络包，网络开发
		- java.awt.*     //做java的界面开发，GUI

## 如何引入包

- 引入一个包的主要目的是使用该包下的类
	- `eg. import java.util.Scanner` 即为引入一个类`Scanner`
	- `eg. import java.util.*` 表示将包`Java.util`内的所有类都引入
	-  **建议：** 需要使用什么类就引入什么类，而不是引用所有类

## 注意事项和使用细节

- package的作用是声明当前类所在的包，需要放在class的最上面，一个类中最多只有一句package
- import指令 位置放在package的下面，在类定义前面，可以有多句且没有顺序要求


# 访问修饰符（重中之重）

- Java提供四种访问修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）：
	- 公开级别：用`public`修饰，对外公开
	- 受保护级别：用`protected`修饰，对子类和同一个包的类公开
	- 默认级别：没有修饰符，向同一个包的类公开
	- 私有级别：用`private`修饰，只有类本身可以访问，不对外公开

| 访问级别| 访问修饰符 | 同类 | 同包 | 子类(同包) | 子类(不同包) | 不同包 |
|:-----:|-----|-----|-----|-----|-----|-----|
| 公开 | public |  √   |  √   | √ |√   |  √   |
| 受保护 |  protected   |  √   |   √  | √ |√/×   |  ×   |
| 默认 |  没有修饰符   |  √   |   √  | √ | ×   |   ×  |
| 私有 |  private  |  √   |  ×   |  ×| ×  |   ×  |

- 注意事项
	- 修饰符可以用来修饰类中的属性，成员方法以及类
	- 只有默认和`public`才能修饰类，并且遵循上述访问的特点（即成员方法 和 成员方法可以由所有修饰符修饰）
	- 因为没有学习继承，因此关于在子类中的访问权限
	- 成员方法的访问规则和属性完全一样

# OOP三大特性（封装、继承、多态）

- **面向对象**的三大特性：**封装**、**继承** 和 **多态**
## 封装

- 将抽象出来的数据\[属性] 和对数据的操作\[方法]封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作\[方法]，才能对数据进行操作。
- 理解和好处
	- 隐藏实现细节
	- 可以对数据进行验证，保证安全合理

### 封装的实现步骤

- 将属性进行私有化(不能直接修改属性)
- 提供一个公共的set方法，用于对属性判断并赋值
```
public void setXxx(类型名 参数名){
	//加入数据验证的业务逻辑
	属性 = 参数名;
}
```
- 提供一个公共的get方法，用于获取属性的值
```
public XX getXxx(){  //获取属性的值
	return xx;
}
```

## 继承

- **问题来源：** 编写两个类，一个是Pupil类(小学生)，另一个是Graduate(研究生)，两个类的属性和方法有很多是相同的，如果重复多写类将会带来冗余，因此引入 **继承** ，使用继承可以提高代码的复用性。
### 基本介绍：

- 继承可以解决代码复用，让编程更加接近人类思维，当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 `extends` 来声明继承父类即可。

### 继承的基本语法

- `class 子类 extends 父类{}`
- 子类会自动拥有父类定义的属性和方法
- 父类又叫 超类，基类
- 子类又叫派生类

### 继承的好处

- 代码的复用性提高了
- 代码的扩展性 和 维护性提高了

### 继承的细节

- 子类继承了所有的属性 和 方法，但私有属性不能再子类直接访问，要通过公共的方法访问
- 子类必须调用父类的构造器，完成父类的初始化（默认情况不用写，系统自动在子类构造器中调用super()函数，表示调用父类构造器）
- 创建子类对象时，不管使用子类的哪个构造器，默认情况总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 `super` 去指定使用父类的哪个构造器完成对父类的初始化，否则，编译不会通过。
- 如果希望指定调用父类的某个构造器，需要显式地调用一下
- `super` 在使用时，需要放在构造器第一行
- `super()` 和 `this()` 都只能放在构造器地第一行，因此这两个方法不能共存在一个构造器中。
	- 注意：这里`this()` 表示构造器的调用
- Java中所有类都是 `Object` 的子类，`Object`是所有类的基类
- 父类构造器的调用不限于直接父类！将一直向上追溯到 `Object` 类（顶级父类）。
- 子类最多继承一个父亲（指直接继承），即Java中是**单继承机制**
	- 应该如何让A类同时继承 B类 和 C类呢？可以让A继承B，B继承C，从而A既继承了B又继承了C。
- 不能滥用继承，子类和父类必须满足 `is-a` 的逻辑关系（即问一个问题：子类是一个父类吗？如果是，可以继承，否则不能继承）

### 继承的本质（内存布局）

```
class GrandPa{  
    String name = "大头爷爷";  
    String hobby = "旅游";  
}  
  
class Father extends GrandPa{  
    String name = "大头爸爸";  
    int age = 39;  
}  
  
class Son extends Father{  
    String name = "大头儿子";   
}

public class ExtendsTheory {  
    public static void main(String[] args) {  
        Son son = new Son();  //执行此步内存中究竟发生了什么？
        System.out.println(son.name);  //返回值是多少？
        System.out.println(son.age);
        System.out.println(son.hobby);
    }  
}
```

- 以此例分析JVM内存（栈区、堆区、方法区）的变化情况
	- 在栈区运行 `main` 方法时，运行至创建 `son` 对象的语句。
	- 要创建 `Son` 对象时，需先加载其父类信息 `Father`，以此向上类推，首先先在 **方法区** 加载 `Object` 信息，然后依次加载 `GrandPa` , `Father` 以及 `Son` 信息。
	- 因为 `new` 语句的存在，需要在堆中为 `Son` 及其 **父类（优先）** 分配内存
		- 首先， 对于 `Object` 类而言，会在 **堆区** 分配空间。 	
		- 其次， 对于 `GrandPa` 类而言，在 **堆区** 分配空间后（包括 **String类型** name 和 hobby 属性的地址），在 **方法区** 的 **常量池** 中存放 name 和 hobby 属性的值（即 ”大头爷爷“ 和 "旅游"）
		- 随后 ，对于 `Father` 类而言，在 **堆区** 分配空间（包括 **String类型**  name 属性的地址 和 **int 类型** age属性的值，即39）后，在 **方法区** 的 **常量池** 中存放 name 属性的值（即"大头爸爸"）。
		- 最后，对于 `Son` 类而言，在 **堆区** 分配空间（包括 **String类型** name 属性的地址 ）后，在 **方法区** 的 **常量池** 中存放 name 属性的值（即"大头儿子"）。 到这，`son` 对象分配完毕。
	- 在栈区运行输出 `son.name` 语句，输出 `大头儿子`：
		- 首先，查看 `son` 对象是否有 `name` 属性；
		- 若有，且可访问，返回此值；
		- 若没有，迭代地对其 最近父类 执行上面步骤，直至某个父类拥有此属性，且可访问，返回其值；否则返回错误（回溯至 `Object` 类依然没有可访问的此属性）。
	- 同理，可以推得栈运行至后面两个语句时，输出分别为 `39` 和 `旅游`。

### super关键字

- 基本介绍：super代表父类的引用，用于访问父类的属性、方法、构造器

- 基本语法：
	- 访问父亲的属性，但不能访问父类的private属性：`super.属性名`
	- 访问父类的方法，不能访问父类的private方法：`super.方法名(参数列表)`
	- 访问父类的构造器：`super(参数列表);`，该句只能放在构造器的第一句，且只能出现一句。

- super 给变成带来的便利以及细节
	- 调用父类构造器的好处（分工明确，父类属性由父类属性初始化，子类属性由子类初始化）
	- 当 子类 中 和 父类 中 的成员（属性和方法）重名时，为了访问父类的成员，必须通过 `super`。如果没有重名，使用super、this、直接访问是一样的效果。
	- `super`的访问不限于父类，如果爷爷类 和 本类中有同名的成员，也可以通过`super` 访问爷爷类的成员；如果多个基类都有同名的成员，使用 `super` 访问遵循就近原则。

- `super` 和 `this` 的比较

| No.| 区别点 | this | super | 
|:-----:|-------|-------|--------|
| 1 | 访问属性 |  访问本类的属性，如果本类没有此属性，从父类继续查找   |  访问父类的属性   | 
| 2 | 调用方法 |  访问本类的方法，如果本类没有此方法，从父类继续查找   |   访问父类的方法  | 
| 3 | 调用构造器 |  调用本类构造器，必须放在构造器的首行   |   调用父类构造器，必须放在子类构造器的首行  | 
| 4 |  特殊  |  表示当前对象   |  子类中访问当前对象   | 

### 方法重写/覆盖（override）

- 基本介绍：**方法覆盖（重写）** 就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法。

- 使用事项 和 注意细节
	- 子类方法的 **参数，方法名称** ，要和父类方法的参数，方法名称完全一样
	- 子类方法的返回类型 和 父类方法返回类型一样，或者父亲返回类型的子类（反之不行）
		- 比如：父类 返回类型 是 `Object`，子类方法的返回类型是String
		- `public Object getInfo()` `public String getInfo()` 二者构成重写关系。
	- 子类方法不能缩小父类方法的访问权限 (可以大于等于)
		- `void sayOk(){}` 和 `public void sayOk()`

- 重写 和 重载的关系

|    名称    |   发生范围     |     方法名       |    参数列表      |   返回类型   |       修饰符    |
|-----------|--------------- |----------------|-----------------|------------   |---------------|
|    重载    |  类内方法的重载 |    类型、个数、顺序至少一个不相同       |    不一致       |  可以不一致 | 无要求  |
|    重写    |  继承中父类与子类对象间|   必须相同    |    一致         | 一致 或 子类返回对象 是 父类返回对象的子类| 子类不能缩小父类的权限 |

## 多态

- **问题来源：** 编写一个程序，Master有一个feed（喂食）方法，可以完成 主人 给动物喂食物的信息。
- 实际实现过程发现：要向不同动物类 喂食 对应的 不同 食物类，需要 **重载** 主人 的 **喂食** 方法，维护非常困难（后续可能需要增加不同种类的动物、食物），代码的复用性不高，由此引入 **多态**。

### 介绍

- 方法 或 对象 具有多种形态，是面向对象的第三大特征，多态是建立在继承基础之上的
- 多态的具体体现
	- 方法的多态
		- 重写 和 重载体现了方法的多态
	- 编译类型 与 运行类型 (子类对象可以赋值给父类对象)
		- 下面 两例都实现了使用父类引用（地址），指向子类的对象（具体空间）。
		- 编译类型：`Aniaml animal = new Dog();` `animal` 编译类型 是 `Animal`，运行类型是 `Dog`
		- `animal = new Cat();` `animal` 的运行类型变成了 `Cat`, 编译类型仍然是 `Animal` 
	- 对象的多态（核心）
		- 一个对象的 **编译类型** 和 **运行类型** 可以不一致
		- **编译类型** 在定义对象时，就确定了，不能改变
		- **运行类型** 是 可以变化的
		- 编译类型 看 定义时 = 号 的 左边，运行类型 看 = 号 的 右边 
		- 使用对象的属性看其编译类型，使用对象的方法看其运行类型

### 多态的注意事项 和 细节讨论

- 多态的前提：两个对象（类）存在继承关系

- 多态的向上转型
	- 本质：父类的引用指向了子类的对象
	- 语法：`父类类型 引用名 = new 子类类型()`
	- 特点：编译类型看左边，运行类型看右边、
		- 可以调用父类中的所有成员（遵守访问权限的前提下）
		- 不能调用子类中的特有成员
			- 因为编译阶段，能调用哪些成员，是由编译类型来决定的
		- 最终运行效果看子类的具体实现

- 多态的向下转型
	- 语法：`子类类型 引用名 = (子类类型) 父类引用`
	- 只能强制父类的引用，不能强转父类的对象
	- 要求父类的引用必须指向当前目标类型的对象
		- `Cat cat = (Cat) animal;  Dog dog = (Dog) animal;`
	- 可以调用子类类型中所有的成员

- 属性没有重写之说，属性的值看编译类型
- `instanceOf` 比较操作符，用于判断对象的类型是否为XX类型 或 XX类型的子类型

### Java的动态绑定机制（非常非常重要）

- 动态绑定机制：
	- 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定
	- 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用


### 多态应用

- **多态数组：** 数组定义类型为父类类型，保存的实际元素类型是子类类型（可通过向下转型调用子类方法，前提是利用Instance of判断属于子类的哪一种）
- **多态参数：** 方法定义的 形参类型 为 父类类型，而实参类型 允许为子类类型


# Object类详解

## equals方法

- `==` 和 equals 的对比
	- `==` 是一个比较运算符
		- `==` ：既可以判断基本类型，又可以判断引用类型
		- `==` ：如果判断基本类型，判断二者值是否相等。
		- `==` ：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象
	- `equals` 方法：是 `Object` 中的方法，只能判断引用类型（但是子类可以不同）。
		- 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，比如 `Integer`, `String`

- 重写 `equals` 方法

## hashCode方法

- 返回该对象 的 哈希码值，为了提高哈希表(java.util.Hashtable) 的性能

### hashCode方法的好处

- 提高具有哈希结构的容器的效率
- 两个引用，如果指向同一对象时，其哈希值是一样的
- 两个引用，如果指向的是不同对象，其哈希值是不一样的
- 哈希值主要根据地址号来确定的，但不能将哈希值 等价于 地址




## toString方法

- 默认返回：全类名（包名 + 类名） + @ + 哈希值的十六进制，子类往往重写`toString`方法，以返回对象的属性信息。

## finalize方法

- 当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法

### 注意事项

- 当对象被回收时，系统自动调用该对象的 `finalize` 方法。子类可以重写该方法，做一些释放资源的操作
- 什么时候回收：当某个对象没有任何引用时，jvm认为该对象是一个垃圾对象，使用垃圾回收机制销毁此对象，在销毁该对象前，会先调用finalize方法
- 垃圾回收机制的调用，由系统决定，也可以通过 `System.gc()` 主动触发垃圾回收机制。
- `finalize` 在开发中几乎不使用，用以面试


# 类变量 和 类方法

- 问题来源：玩游戏过程中，每次都有新的小朋友加入游戏，如何统计小朋友数量？
	- 传统方法：利用 `count` 变量来统计（但是每一次加入新的朋友，都需要采用`count++` 语句，不够自动化，且容易遗忘），`count` 是独立于对象的变量，因此需要采用类变量/静态变量。
- 由此引入 `类变量`，所有 `类实例` 共享此变量。

## 类变量
### 类变量的内存布局

- 静态变量所在位置可能不同，与 `jdk` 版本相关。可能在 堆(`jdk8` 以后 ) 或 方法区的静态区(`jdk8` 前)，`jdk8`以后 保存在 `Class`变量尾部（即**堆区**）。
- static变量，**在类加载时就生成了**。（不是对象，类声明保存在方法区）

### 类变量的解释 以及 定义

- 类变量：也称静态变量/静态属性，是该类所有对象共享的变量，任何一个该类对象访问它时，取得的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

- 类变量定义 **语法** ：
	- `访问修饰符 static 数据类型 变量名` (推荐)
	- `static 访问修饰符 数据类型 变量名`

- 如何访问类变量：
	- `类名.类变量名`
	- `对象名.类变量名`
	- 推荐使用 `类名.类变量名`

- 类变量的访问，同样需要遵守 访问权限

### 类变量的使用

- 使用时机：某个类的所有对象共享一个变量时，比如：定义学生类，统计所有学生交了多少钱
- 类变量 与 实例变量（普通属性）区别：类变量是所有对象共享，实例对象是每个对象独享的
- 加上static 称为类变量 或 静态变量，否则称为实例变量/普通变量/非静态变量
- 实例变量不能通过 类名.类变量名 方式访问
- 类变量在类加载的时候就初始化了，即，即使没有创建对象，只要类加载了，就可以使用类变量了。
- 类变量的生命周期：随类的加载开始，随类的消亡而销毁。

## 类方法

### 基本介绍

- 也叫静态方法
- 语法：
	- `访问修饰符 static 数据返回类型 方法名() {}` (推荐)
	- `static 访问修饰符 数据返回类型 方法名() {}`
- 调用：
	- `类名.类方法名 或 对象名.类方法名`【必须满足访问修饰符的访问权限和范围】
### 使用场景

- 当方法中不涉及到任何和对象相关的成员时，可以将方法设计为静态方法，提高开发效率

### 注意事项 和 细节讨论

- 类方法 和 普通方法 都随着类的加载而加载，将结构信息（抽象而非具体）存储在方法区，类方法中无 `this` 的参数，普通方法中隐含着 `this` 的参数
- 类方法可以通过类名调用，也可以通过对象名调用
- 普通方法和对象有关，需要通过对象名调用，比如`对象名.方法名(参数)`，不能通过类名调用
- 类对象不允许使用和对象有关的关键字，比如 `this` 和 `super`，普通方法（成员方法）可以。
- 类方法（静态方法）中，只能访问 静态变量 或 静态方法
- 普通成员方法，既可以访问普通变量（方法），也可以访问静态变量（方法）。
- 总结：静态方法，只能访问静态的成员，非静态的方法，也可以访问静态成员和非静态成员。
- 补充：静态变量，也只能调用静态方法 或 静态变量，不能在类中直接通过静态变量访问 普通方法或 普通变量 

# 理解 `main` 方法语法

 > `public static void main(String[] args)` 声明的原因

- `main` 方法由虚拟机所调用
- Java虚拟机需要调用类的 `main()` 方法，所以该方法的访问权限必须是 `public`
- Java虚拟机在执行 `main()` 方法时不必创建对象，所以该方法必须是 `static`
- 该方法接收 `String` 类型的数组参数，保存执行 `java` 命令时传递给所运行的类的参数
- Java 执行的程序 参数1 参数2 参数3

## 注意事项

- `main()` 方法中，可以直接调用 `main` 方法中所在类的静态方法 或 静态属性
- 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象，才能通过这个对象去访问类中的非静态成员。

### 如何在IDEA中传入main的参数

- 打开编辑配置
- 在程序实参中 键入实参数据

# 代码块

## 基本介绍

- 代码块又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体内，通过 `{}` 包围起来
- 和方法不同，没有方法名，没有返回，没有参数，只有方法体，且不能通过对象或类显式调用，加载类时，或创建对象时隐式调用

## 基本语法

```
[修饰符]{
	代码
};
````

- 修饰符 可选，要写的话，只能写 `static`
- 代码块分为两类：有 `static` 修饰的静态代码块，没有 `static` 修饰的普通代码块
- 逻辑语句可以包含任意逻辑语句 （输入、输出、方法调用、循环、判断等）
- `;` 号可以写上，也可以省略

## 代码块的好处

- 相当于另一种形式的构造器（对初始化的补充机制），可以做初始化的操作
- **场景：** 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性

## 注意事项 和 细节讨论

- static代码块也叫静态代码块，作用是对类进行初始化，随着**类的加载**而执行，且只会执行一次，如果是普通代码块，每创建一个对象，就执行一次。

- 类什么时候被加载？
	- 创建对象实例时(new)
	- 创建子类对象实例，父类也会被加载
	- 使用类的静态成员时（静态属性，静态方法）

- 普通代码块，在创建对象实例时，会被隐式地调用，被创建一次就会调用一次，如果只是使用类的静态成员时，普通代码块并不会执行。

- 创建一个对象时，在一个类 调用顺序是：
	- 调用 静态代码块 和 静态属性 初始化（静态代码块 和 静态属性初始化调用的有限集一样，如果多个静态代码块 和 多个静态变量初始化，按它们定义的顺序调用）
	- 调用普通代码块 和 普通属性 的初始化（普通代码块 和 普通属性初始化调用的优先级一样，如果有多个普通代码块 和 多个普通属性的初始化，则按定义顺序调用）
	- 调用构造方法

- 构造方法（构造器）的最前面其实隐含了 `super()` 和 调用普通代码块，静态相关的代码块、属性初始化，在类加载时，就执行完毕，因此是优先于 构造器 和 普通代码块

```
class A{
	public A(){
		super();
		//调用普通代码块
		System.out.println("ok");
	}
}
```

> 执行顺序：静态代码块/静态属性初始化  --> super()  --> 普通代码块   --> 构造函数自定义语句

- 创建一个子类（继承关系），静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序如下：
	- 父类的 静态代码块 和 静态属性（优先级相同，按定义顺序执行）
	- 子类的 静态代码块 和 静态属性（优先级相同，按定义顺序执行）
	- 父类的 普通代码块 和 普通属性初始化（优先级相同，按定义顺序执行）
	- 父类的构造方法
	- 子类的 普通代码块 和 普通属性初始化（优先级相同，按定义顺序执行）
	- 子类的构造方法

- 静态代码块只能直接调用 静态成员（静态属性 和 静态方法），普通代码块可以调用任意成员

# 单例设计模式


- **设计模式：** 大量实践中总结 和 理论化之后优选的代码结构、编程风格以及解决问题的思考方式

- **单例模式：**  采取一定的方法保证在整个的软件系统中，对某个类只存在一个对象实例，并且该类只提供一个取得其对象实例的方法。单例模式有两种方式：
	- 饿汉式
	- 懒汉式

> 单例即单个实例，一个对象只创建一个实例

- `饿汉式` 构建步骤：
	- 构造器私有化（防止直接new）
	- 类的内部创建对象
	- 向外暴露一个静态的公共方法 (getInstance)
	- 代码实现

- `懒汉式` 构建步骤：
	- 构造器私有化
	- 定义一个 `static` 静态属性对象
	- 提供一个 `public` 的 `static` 方法，可以返回一个对象
	- 懒汉式，只有当用户使用 `getInstance` 时，才返回 `Cat` 对象，后面再次调用时，会返回上次创建的对象。

- 区别
	- 最主要区别：饿汉式在类加载时就创建了对象实例，而懒汉式是在使用时才创建
	- 饿汉式不存在线程安全问题，懒汉式存在线程安全问题
	- 饿汉式存在资源浪费的可能。如果一个实例都没有使用，创建的对象就可能浪费了
	- `JavaSE`标准类中，`java.lang.Runtime` 是经典的单例模式。

# `final` 关键字

## 基本介绍

- 可用以修饰类、属性、方法和局部变量
- 用途：
	- 不希望类被继承时，可用 `final` 修饰
	- 不希望父类的某个方法被子类覆盖/重写(override)时，可以用 `final` 关键字修饰
	- 不希望类的某个属性值被修改，可以用 `final` 修饰
	- 不希望某个局部变量被修改，可以使用 `final` 修饰（变量加上`final`修饰后，也被称为局部常量）

## 注意事项 和 细节讨论

- `final` 修饰的属性又叫常量，一般用 `XX_XX_XX` 来命名（大写）

- `final` 修饰的属性在定义时，必须赋初值，不能再修改，赋值位置：
	- 定义时，`public final double TAX_RATE = 0.08;`
	- 构造器中
	- 代码块中

- 如果 `final` 修饰的属性是静态变量，则初始化的位置只能是：
	- 定义时
	- 静态代码块中
	- （不能在构造器中赋值）

- `final` 类不能继承，但是可以实例化对象
- 如果类不是 `final` 类，但是含有 `final` 方法，虽然该方法不能重写，但是可以被继承
- 一般来说，如果一个类已经是 `final` 类了，就没有必要再将方法修饰为 `final` 方法
- `final` 不能修饰构造方法（构造器）
- `final` 和 `static` 往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理
- 包装类(`Integer,Double,Float,Boolean`等都是`final`)，`String` 也是 `final` 类。

# 抽象类

## 问题来源

- 当父类某些方法，需要声明，但是又不知道如何实现时，可以将其声明未抽象方法，那么此类就是抽象类。

## 抽象类介绍

- 用 `abstract` 关键字修饰一个类时，该类就叫抽象类：
	- `abstract 访问修饰符 类名{}`
- 用 `abstract` 关键字来修饰一个方法时，这个方法就是抽象方法
	- `访问修饰符 abstract 返回类型 方法名(参数列表)`
- 抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类

## 注意事项 和 使用细节

- 抽象类不能被实例化，只能被继承
- 抽象类不一定包含 `abstract` 方法，即抽象类可以没有 `abstract` 方法
- 一旦类包含了 `abstract` 方法，则这个类必须声明为 `abstract`
- `abstract` 只能修饰类和方法，不能修饰属性和其它的。
- 抽象类可以有任意成员【因为抽象类还是类】，比如：非抽象方法、构造器、静态属性等
- 抽象方法不能有主体，即不能实现
- 如果一个类继承了抽象类，它必须实现抽象类的所有抽象方法，除非它自己也声明为 `abstract` 类
- 抽象方法不能使用 `private`、`final` 和 `static` 来修饰，这些关键字和重写是相违背的。


## 抽象类最佳实践 - 模板设计模式

- 需求：(1) 有多个类，完成不同的任务job (2) 要求统计得到各自完成任务的实践
# 接口

## 基本介绍

- **接口：** 给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。

- **语法：** 
	- 接口定义：`interface 接口名 {//属性   //方法}` 这里的方法可以是：抽象方法/ 默认实现方法/ 静态方法
	- 接口实例：`class 类名 implements 接口{//自己属性  // 自己方法   必须实现的接口的抽象方法}` 

- Jdk7.0前，接口所有方法都没有方法体，即都是抽象方法；Jdk8.0后，接口可以有静态方法，默认方法（需使用 `default` 关键字），即接口中可以有方法的具体实现。

## 使用场景

- 制造战斗机，专家只需要把飞机所需功能/规格规定下来即可，然后交由别的人去实现。
- 项目经理，管理3个程序员，开发一个软件，为控制和管理软件，项目经理可以定义一些接口，由程序员具体实现。

## 注意事项 和 使用细节

- 接口不可以实例化（接口可以理解为一个抽象类）
- 接口中所有的方法都是 `public` 方法，接口中抽象方法，可以不用 `abstract` 和 `public` 来修饰
- 一个普通类实现接口，就必须将该接口的所有方法都实现
- 抽象类实现接口，可以不用实现接口的方法
- 一个类同时可以实现多个接口
- 接口的属性只能是 `final` 的，而且是 `public static final` 修饰符，比如：`int a = 1` 实际上是 `public static final int a = 1;`
- 接口中属性的访问形式：接口名.属性名
- 一个接口不能继承其它的类，但可以继承 **多个** 别的接口
- 接口的修饰符 只能是 `public` 和 默认，这点和类的修饰符是一样的

## 接口 和 继承类

- 接口是对 **Java单继承机制** 的补充
- 接口 和 继承解决的问题是不一样的
	- 继承的主要价值：解决代码的复用性 和 可维护性
	- 接口的主要价值：设计，设计好各种规范（方法），让其它类去实现这些方法
- 接口比继承更加灵活
	- 接口比继承更加灵活，继承是满足 `is - a` 的关系，接口只需满足 `like -a `的关系
	- 接口在一定程度上实现代码解耦

## 接口的多态特性

- 多态参数，形参是接口类型，接收实现了接口的对象实例
- 多态数组（和前面类似）
- 多态传递现象：接口2 继承 接口 1，类1 实现 接口2，那么自动地，类1 实现了 接口1。

# 内部类

## 基本介绍

- 类的内部又完整地嵌套了另一个类结构。被嵌套地类称为 **内部类**，嵌套其它类的类称为 **外部类**。内部类最大的特点是可以直接访问私有属性，且可以体现类与类的包含关系。

## 内部类的分类

- 根据定义在外部类局部位置上（比如方法内）：
	- 局部内部类（有类名）
	- 匿名内部类（没有类名，重点）

- 定义在外部类的成员位置上：
	- 成员内部类（没有static修饰）
	- 静态内部类（使用static修饰）

## (1) 局部内部类

- 定义在外部类的局部位置，比如方法中，且有类名
- 可以直接访问外部类的所有成员，包含私有的
- 不能添加访问修饰符，因为它的地位就是一个局部变量，局部变量不能使用修饰符，但可以使用`final`修饰，因为局部变量也可以使用 `final`
- 作用域：定义其的方法或代码块（等价于在构造函数）中
- 局部内部类可以直接访问外部类成员
- 外部类在方法中，可以创建对象，然后调用方法即可
- 外部其它类 -- 不能访问内部类（因为局部内部类地位是要一个局部变量）
- 外部类 和 局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类.this.成员) 去访问

## (2) 匿名内部类

- 定义在外部类的局部位置，比如方法中，且没有类名
- 语法：`new 类或接口(参数列表){类体};`
- 需求：使用某个接口，创建对象（但仅仅使用一次）
	- 传统方式：写一个类，实现本接口，并创建对象
	- 匿名内部类方式：在方法中 `new` 一个 类 或 接口，赋给 接口 或 类，在方法体并重写方法，在底层自动创建此类，并分配空间
- 利用匿名内部类可以简化开发

### 注意事项 和 使用细节

- 匿名内部类既是一个类的定义，本身也是一个对象，从语法上看，既有定义类的特征，也有创建对象的特征。
- 可以直接访问外部类的所有成员，包括私有的
- 不能添加修饰符，因为其本质是一个局部变量
- 作用域：仅仅在定义它的方法或代码块中
- 外部其它类 不能访问 匿名内部类
- 如果外部类 和 内部类 的成员重名时，内部类访问的话，遵循就近原则，如果想访问外部类成员，可以使用 (外部类名.this.成员) 去访问

### 匿名内部类的最佳实践

- 当作实参直接传递，简洁高效


## (3) 成员内部类

- 定义在外部类的成员位置，可以访问外部的所有 成员属性 和 成员方法
- 可以添加任意的访问修饰符(public、protected、默认、private)，因为它的地位是一个成员
- 作用域：和外部类其它成员一样
- 成员内部类 访问 外部类成员 直接访问即可
- 外部类 访问 成员内部类，先创建对象，在访问
- 外部其它类 访问 成员内部类
	- 方式1：`外部其他类 类名 = 外部类.new 内部类`
	- 方式2：外部类中编写一个方法`例如 getInstance`，返回内部类
		- `Outer.Inner i1 = Outer.getInstance()`
- 如果外部类 和 内部类 的成员重名时，内部类访问的话，遵循就近原则，如果想访问外部类成员，可以使用 (外部类名.this.成员) 去访问

## (4) 静态内部类

- 定义在外部类的成员位置，且有static修饰
- 可以直接访问外部类的所有静态成员，包含私有的，但不能访问非静态成员
- 可以添加任意访问修饰符，因为它的地位就是一个成员
- 作用域：同其他成员，为整个类体
- 静态内部类 访问 外部类，能够直接访问所有静态成员
- 外部类 访问 静态内部类，创建对象，再访问
- 外部其它类 访问 静态内部类
	- 方式1：`外部类.内部类 类名 = new 外部类.内部类()`
	- 方式2：编写一个方法，返回静态内部类的对象实例
- 如果外部类 和 静态内部类 的成员重名时，静态内部类访问的话，遵循就近原则，如果想访问外部类成员，可以使用 **(外部类名.成员)** 去访问

# 泛型的理解和好处

- 不能对加入到集合 `ArrayList` 中的数据类型进行约束（不安全）
- 遍历的时候，需要进行类型转换，如果集合中的数据量比较大，对效率有影响

> 因此，使用泛型来解决

- 编译时，自动检查元素的类型，提高了安全性
- 减少了类型转换的次数，提高效率
- 不再提示编译警告

## 泛型的介绍

- 泛型又称为参数化类型，是 `jdk5.0` 出现的新特性，解决数据类型的安全性问题
- 在类声明或实例化时，只要制定好需要的具体的类型即可
- `Java` 泛型可以保证如果程序在编译时没有发出警告，运行时不会产生 `ClassCastException` 异常，同时，代码更加简洁、见状
- 泛型的作用：可以是类声明时，通过一个标识来表示类中某个属性的类型，或者是某一个方法的返回值的类型，或者是参数类型



# 泛型语法

## 泛型的声明

- `interface 接口<T>{}` 和 `class类<K,V>{}`
	- 其中 `T,K,V`不代表值，而是表示类型
	- 任意字母都可以，常用 `T`，是 `Type` 的缩写

- 泛型的实例化
	- `List<String> strList = new ArrayList<String>();`
	- `Iterator<Customer> iterator = customers.iterator();`

## 泛型使用的注意事项 和 细节

- `interface List<T>{}, public class HashSet<E>{}..` 等等
	- `<T,E>` 只能是引用类型
- 在指定泛型具体类型后，可以传入该类型 或者 其子类类型
- 泛型的使用形式
	- `List<Integer> list1 = new ArrayList<Integer>();`
	- `List<Integer> list2 = new ArrayList<>();`
- 如果写为：`List list3 = new ArrayList();` 默认给它的 泛型是 【\<E> E就是 `Object`】

# 自定义泛型

### 基本语法

```
class 类名<T,R...>{
	成员
}
```

- 注意细节
	- 普通成员可以使用泛型
	- 使用泛型的数组，不能初始化(指定数组大小)
	- 静态方法中不能使用类的泛型
	- 泛型类的类型，是在创建对象时确定的（创建对象时，需要指定确定类型）
	- 如果在创建对象时，没有指定类型，默认为 `Object`

## 自定义泛型接口

### 基本语法

```
interface 接口名<T,R...>{

}
```

- 注意细节
	- 接口中，静态成员不能使用泛型
	- 泛型接口的类型，在继承接口 或 实现接口时确定
		- 继承接口时，必须指定类型
	- 没有指定类型，默认为 `Object`

## 自定义泛型方法

### 基本语法

```
修饰符<T,R...>返回类型 方法名(参数列表){

}

```

- 使用细节
	- 泛型方法，可以定义在普通类中，也可以定义在泛型类中
	- 当泛型方法被调用时，类型会确定
	- `public void eat(E e){}`，修饰符后没有 `<T,R..>`，`eat`方法不是泛型方法，而是使用了泛型
		- 泛型方法：`public <T,R..> void eat(E e){}`
		- 使用了泛型的方法：`public void eat(E e){}`




# 泛型的继承 和 通配符

## 说明

- 泛型不具有继承性
	- `List<Object> list = new ArrayList<String>();` 不正确
- `<?>`：支持任意泛型类型
- `<? extends A>`：支持A类以及A类的子类，规定了泛型的下限
- `<?super A>`：支持A类以及A类的父类，规定了泛型的下限

# 线程介绍

## 相关概念

- **程序：** 完成特定任务、用某种语言编写的一组指令的集合（简单来说，写的代码）
- **进程**：运行的程序，比如使用的QQ，就启动了一个进程，OS为其分配内存空间。
	- 是程序的一次执行过程，或是正在进行的一个程序。是动态过程：有它自身的产生、存在和消亡的过程
- **线程**：由进程创建的，是进程的一个实体
	- 一个进程可以拥有多个线程
	- 示例：打开迅雷下载多个软件的任务，就可以看作一个线程
	- **单线程**：同一个时刻，只允许执行一个线程
	- **多线程**：同一个时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件。
- **并发**：同一个时刻，多个任务交替执行，造成一种”貌似同时“的错觉，简单说，单核cpu实现的多任务就是并发。（一边开车一边打电话，一边说话一边打字）
- **并行**：同一个时刻，多个任务同时执行。多核cpu可以实现并行。



# 线程创建


## 创建线程的两种方式

- 继承`Thread`类，重写 `run` 方法
	- `class Cat extends Thread{public void run(){}}` //重写 `Thread` 中的 `run` 方法
		- 在创建一个类`Cat cat`中，调用 `cat.start()`，即可实现两个线程（`main` 和 `Thread`）多核-并行（单核-并发）运行。如果只调用 `cat.run()` 就相当于直接在主线程 `main` 中直接调用方法（此时`run`方法只是一个普通方法，`run`执行完毕才会向下走），不会创建`Thread-0`线程。
	- 个人感悟：线程让类”活"了。

- 实现 `Runnable` 接口，重写 `run` 方法
	- 因为 `java` 是单继承的，在某些情况下一个类可能已经继承了某个父类，这时候再用继承 `Thread` 类方法 来创建线程显然不可能了
	- 因此可以使用 实现 `Runnable` 接口 来创建线程
	- `class Cat implements Runnable{public void run(){}}`，在主线程中使用 `Dog dog = new Dog(); Thread thread = new Thread(dog); dog.start();` 实现多线程编程。这里运用了 【代理模式】


- 当 `main` 线程启动一个子线程 `Thread-0`，主程序不会阻塞（主程序 和 子程序同步进行）
-  线程的理解：孙猴子用猴毛同时做多件事情

- 继承 `Thread` vs 实现 `Runnable` 的区别
	- 从 `java` 设计来看，通过继承 `Thread` 或者 实现 `Runnable` 接口来创建线程本质上没有区别，因为 `Thread` 本身就实现了 `Runnable` 接口
	- 实现 `Runnable` 接口方式更加适合多个线程共享资源的情况，并且避免了单线程的限制，建议使用 `Runnable`


# 线程终止

## 基本说明

- 当线程完成任务时，会自动退出
- 还可以通过使用变量来控制 `run` 方法退出的方式停止线程，即通知方式


# 线程方法

## 常用方法

- `setName`：设置线程名，使之与参数 `name` 相同
- `getName`：返回该线程名
- `start`：使该线程开始执行；`Java` 虚拟机底层调用该线程的 `start0` 方法
	- 创建新的线程，直接调用 `run`，`run`就是一个简单的方法调用，不会启动新线程
- `run`：调用线程对象的 `run` 方法
- `setPriority`：获取线程的优先级
	- `public static final int MAX_PRORITY 10`
	- `public static final int MIN_PRORITY 1`
	- `public static final int NORM_PRORITY 5`
- `sleep`：在指定的毫秒数让当前正在执行的线程休眠（暂停执行）
	- 线程的静态方法，使当前线程休眠
- `interrupt`：中断线程
	- 并没有真正地结束线程，一般用于中断正在休眠线程

- `yield`：线程的礼让，让出 `cpu`，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功
- `join`：线程的插队，一旦插队成功，则肯定先执行完线程的所有的任务

## 用户线程 和 守护线程

- 用户线程：也叫工作线程，当线程的任务执行完或通知方式结束
- 守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束
	- 语法：`threadxxx.setDaemon(true)` 将线程设置成守护线程
- 常见的守护线程：垃圾回收机制

## 线程的生命周期

- `NEW`：尚未启动
- `RUNNABLE`：执行中
- `BLOCKED`：被阻塞等待监视器锁定
- `WAITING`：等待另一个线程执行特定动作
- `TIMED_WAITING`：等待另一个线程执行动作达到指定等待时间
- `TERMINATED`：已退出的线程

# `Synchronized`

## 线程同步机制

- 多线程编程中，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。
- 线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其它线程才能对该内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。

## 具体方法

- 同步代码块（在方法中使用此语句可保证方法变为同步方法）
```
sychronized(对象){//得到对象的锁，才能操作同步代码
	//需要被同步代码
}
```

- 放在方法声明中，表示整个方法为同步方法
```
public synchronized void m(String name){
// 需要被同步的代码
}
```
 


# 互斥锁

## 基本介绍

- 引入对象互斥锁，保证共享数据操作的完整性
- 每个对象都对应一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象
- 关键字 `synchronized` 来与对象的互斥锁联系，当某个对象用 `synchronized` 修饰时，表示该对象
- 同步的局限性：导致程序的执行效率降低
- 同步方法（非静态的）的锁可以是 `this`，也可以是其他对象（要求是同一个对象）
- 同步方法（静态的）的锁为当前类本身`synchronized(类名.class)`

## 注意事项 和 细节

- 同步方法如果没有使用 `static` 修饰，默认锁对象为 `this`
- 如果方法使用 `static` 修饰，默认锁对象：`当前类.class`
- 实现的落地步骤
	- 先分析上锁的代码
	- 选择同步代码或同步方法
	- 要求多个线程的锁对象为同一个即可


# 死锁

## 基本介绍

- 多个线程都占用了对方的锁资源，但不肯相让，导致死锁，编程中需要避免死锁的发生

## 释放锁的情况

- 线程的同步方法、同步代码块执行结束
- 当前线程在同步代码块、同步方法中遇到 `break、return`
- 当前线程在同步代码块、同步方法中出现了未处理的 `Error` 或  `Exception`，导致异常结束。
- 当前线程在同步代码块、同步方法中执行了线程对象的 `wait()` 方法，当前线程暂停，并释放锁

## 不会释放锁的情况

- 线程执行同步代码块或同步方法时，程序调用 `Thread.sleep()`、`Thread.yield()`方法暂停当前线程的执行，不会释放锁
- 线程执行同步代码块时，其他线程调用了该线程的 `suspend()` 方法将该线程挂起，该线程不会释放锁。
	- 应尽量避免使用 `suspend()` 和 `resume()` 来控制线程，方法不再推荐使用

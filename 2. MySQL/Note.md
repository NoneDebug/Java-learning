
# Chap 1 相关概念

- 数据库：`Database`，简称 `DB`，用于将数据格式化保存
	- 本质：存储数据的仓库，实际就是一堆文件，这些文件中存储了具有特定格式的数据
- 数据库管理系统：`DataBaseManagement`，简称 `DBMS`
	- 管理数据库中数据，对数据库数据进行 `crud`
	- 常见 `DBMS`：`MySQL`、`Oracle`、`MS SqlServer`、`DB2`、`sybase`等...
- `SQL`：结构化查询语言
	- 编写SQL语句，`DBMS`负责执行 `SQL` 语句，最终来完成数据库中数据的增删改查操作
	- 一套标准，在不同 数据库管理系统都可以使用。
- 三者关系：
	- `DBMS`：通过执行 `SQL` 操作 `DB`

- 端口号：任何一个软件/应用都会有的，应用的唯一代表，通常和 `IP` 地址在一块，`IP` 地址用以定位计算机， `port` 用以定位某个服务或应用的。一台计算机上，端口号不能重复，具有唯一性。
	- `MySQL` 数据库启动的时候，这个服务占有的默认端口号是 `3306`

- 字符编码集：`MySQL`数据库字符编码方式为 `utf-8`，


# Chap 2 常用命令

- 登录 `MySQL` 命令：在终端输入 `mysql -u用户名 -p密码` 即可实现登录
- `MySQL` 常用命令（不区分大小写）：
	- 退出：`exit`
	- 查看 `mysql` 中的数据库：`show databases;`
		- 默认有四个数据库：
			- information_schema
			- mysql
			- performance_schema
			- test
	- 选择数据库：`use 数据库名;` // 表示使用数据库名对应的数据库
		- 展示表：`show tables`，确定库后就可以用此命令展示该库下所有表格
	- 创建数据库：`create database 数据库名;` //表示创建数据库名对应的数据库

	- 删除数据库：`delete 数据库名;`
	

- 数据库中最基本的单元为：**表**
- 数据库中以表格的形式来表示数据的
	- `行(row)`：被称为 数据 / 记录
	- `列(column)`：被称为字段，每个字段都有对应的名字、数据类型、约束等属性
		- 字段名：普通名，见名知意
		- 数据类型：字符串、数字、日期等
		- 约束：对数据值进行约束

- `SQL` 语句的分类
	- 分为：
		- `DQL`：数据查询语言（凡是带有 `select` 关键字的都属于它）
		- `DML`：数据操作语言（凡是对表数据进行 增删改的都属于它）
			- `insert`、`delete`、`update`
		- `DDL`：数据定义语言（凡是带有 `create`、`drop`、`alter`的都属于它）
			- 对表的结构而非数据进行修改
		- `TCL`：事务控制语言
			- 包括：事务提交：`commit`，事务回滚：`rollback`
		- `DCL`：数据控制语言
			- 授权：`grant`，撤销权限：`revoke`

- 不看表格的数据，只看表的结构
	- `desc 表名;` (是 `desrcibe` 命令的缩写，使用 `describe 表名` 命令也可以)
 
- `varchar` 表示 `Java` 类型中的 `String` 

- `select version();`：查看 `mysql` 语句 的版本号
- `select database();` ：查看当前使用数据库的名字

- `mysql` 不见分号不执行
- `\c` 终止当前命令


# Chap 3 查看“演示数据”表结构

- 略

# Chap 4 简单查询



- 查询一个字段
	- 语法：`select 字段名 from 表名;`
	- `select` 和 `from` 都是关键字；`字段名` 和 `表名` 都是标识符
	- 注意：对于 `SQL` 语句是通用的，所有的 `SQL` 语句 以 `;` 结尾，`SQL` 不区分大小写

- 查询多个字段
	- 语法：`select 字段名1, 字段名2, ..., 字段名n from 表名;`

- 查询所有字段：
	- 语法：`select * form 表名;` 或 所有字段都写上
	- `*` 效率比较低，因为 `SQL` 会将其转化为字段，影响效率；且可读性查，开发中不建议使用，可以在 `DOS` 中查看全表内容

- 给查询的列起个别名
	- 语法：`select 表名.字段名 as 别名`，使用的是 `as` 关键字
	- 注意：只是将查询结果列名显示为 `别名`，原表列名不变，因为其只负责查询
	- 也可以将 `as` 替换为空格
	- 如果别名中间出现空格，会被 `mysql` 识别为 部分别名，可以使用 一对`''` 将 别名引起来，实现起有空格的别名。
		- 注意：不能使用 `" "` 进行引用，因为所有数据库中，字符串统一使用 单引号括起来，单引号是标准，双引号在 `Oracle` 中用不了。在 `mysql` 可以使用。
	- 注意：别名不能直接使用中文，可以用 `''` 引起来起别名

- 字段可以使用字段表达式
	- 语法：e.g. `select sal * 12 as sal_year from emp`  计算员工年薪


# Chap 5 条件查询

- 用到 `where` 语句，必须放到 `from` 语句表的后面

- 支持运算符

相关条件：

| 运算符 | 说明 |
| ---- | ---- |
| `=` | 等于 |
| `<>或 !=` | 不等于 |
| `<` | 小于 |
| `>` | 大于 |
| `>=` | 大于等于 |
| `between ... and ...` | 两个值之间，相当于 >= and <=，必须遵循左小右大，不然返回的肯定是空集 |
| `is null` | 为 `null`( `is not null` 为空)，注意，必须 用 `is null` 而不是 `= null` |
| `and` | 且 |
| `or` | 或者 |
| `in` | 包含，相当于多个 `or`（`not in` 不在这个范围中 ） |
| `not` | 非，逻辑取反 |
| `like` | 模糊查询，支持 `%` 和 下划线匹配，`%` 匹配任意个字符，下划线，一个下划线只匹配一个字符 |
- `and` 和 `or` 同时出现，优先级？
	- `and` 优先级 比 `or` 高
	- 可以使用 `()` 提高优先级

- `in` 后面接 `()`，不是一个区间，而是一个集合（具体的值），`not in` 则表示不在这些值中的数据

- 如果需要查找的数据中含有 `%` 或 `_` ，需要使用转义字符 `\`



# Chap 6 排序

## 单字段排序

- 语法：`select 字段名1, 字段名2,..., 字段名n from 表名 ORDER BY 字段名k`
- 默认是升序，若要使用降序，语法为：
	- `select 字段名1, 字段名2,..., 字段名n from 表名 ORDER BY 字段名k desc`
- 指定升序：
	- `select 字段名1, 字段名2,..., 字段名n from 表名 ORDER BY 字段名k asc`

## 多字段排序

- 语法：`select 字段名1, 字段名2, ..., 字段名n from 表名 order by 字段名i1 [asc/desc], 字段名 i2 [asc/desc], ..., 字段名 ik [asc/desc]`
- 注意：越靠前的字段名起主导作用，表示先按照某个字段进行排序，若前面字段相等，才会按照后面字段进一步进行排序。

## 根据位置进行排序

- 语法：`select 字段名1, 字段名2, ..., 字段名n from 表名 order by n` 表示按照第 n 列的字段进行排序
- 注意：开发中，不建议这么书写，因为不健壮，列的顺序发生改变后，结果不相同


## 关键字顺序

- `select ... from ... where ... order by ...`：排序总是在最后执行


# Chap 7 数据处理函数/单行处理函数


## 数据处理函数又被称为单行处理函数

- 逐行处理，一个输入对应一个输出
- 对应：多行处理函数（特点：多个输入，对应1个输出，举例求工资总和）
- 直接将下面的函数名后加括号 `()` ，括号中放入要处理的字段名，即可实现对字段的内容进行处理。

| 函数名 | 功能 | 注意 |
| ---- | ---- | ---- |
| Lower | 转换小写 |  |
| Upper | 转换大写 |  |
| substr(被截取的字符串, 起始下标, 截取的下标) | 取子串 | 起始下标从1开始 |
| length | 取长度 |  |
| trim | 去空格 | 去除字符串 |
| str_to_date | 字符串转为日期 |  |
| data_format | 格式化日期 |  |
| format | 设置千分位 |  |
| round() | 四舍五入 | round(a, p)，a表示要处理的数，p表示要保留的小数个数，可以是负数，表示小数点前的值 |
| rand() | 生成随机数 | 生成\[0,1] 的随机数 |
| ifnull() | 将null转换为一个具体值 | 因为`mysql`中，任何和`null` 进行算数运算的结果都是 `null`，`ifnull()`就是为了处理这种情况而产生的，`ifnull(数据，被当作的值)` |
| concat(str1, str2) | 对字符串str1 和 str2进行性拼接 |  |
| `case..when..then..when..then..else..end` |  | 返回的是 `then` 后的值，`case` 后是判断的字段名，`when` 后是判断所属值 |
- `select 'abc' from 表名`：会返回一个名为 `'abc'` 的表，值全为 `abc`，且和原数据量相同，即 `select` 后面可以跟字面量/字面值



# Chap 8 分组函数/聚合函数/多行处理函数

- 特点：输入多行，输出一行
- 5个函数
	- `count`：计数
		- `count(*)`：表示求数据量有多少
	- `sum`：求和
	- `avg`：平均值
	- `max`：最大值
	- `min`：最小值
- 必须先进行分组，才能用，如果没有对数据进行分组，整张表默认为一组
- 自动忽略 `null`，不需要提前对 `null` 进行处理。
- 分组函数不能直接使用在 `where` 子句中
- 所有分组函数可以组合在一起使用

# Chap 9  分组查询（非常重要）

- 定义：实际应用中，需要先进行分组，再对每组数据进行操作
- 关键字组合顺序，以下顺序不能颠倒：
```
select
...
from
...
where
...  //不可使用分组函数，因为 where的执行顺序在 group 之前
group by
... 
having 
... //对分组之后的数据进行进一步筛选
order by
...
```
- 执行顺序为：`from`、`where`、`group by`、`having`、`select`、`order by`

- `having` 语句可以对分完组的数据进行进一步过滤
	- 不能代替 `where` ，必须和 `group by` 联合使用
	- 但是 `having` 语句效率比较低，能使用 `where` 尽量使用 `where`

- `distinct` 关键字
	- 去除重复记录
	- 只能出现在所有字段的最前方
	- 出现在 多个字段之前，表示多个字段联合去重


# Chap 10 连接查询（最重要）

- 连接查询：从一张表中单独查询，称为单表查询；从表1取若干字段，从表2取若干字段，连接起来查询数据，称为连接查询。

- 分类（按照年代分）：
	- `SQL92`
	- `SQL99`

- 根据表连接方式分类：
	- 内连接：
		- 等值连接
		- 非等值连接
		- 自连接
	- 外连接：
		- 左外连接（左连接）
		- 右外连接（右连接）
	- 全连接

- 两张表进行连接查询，如果没有条件限制时，对应的结果条数为两表条数相乘的结果，这种现象叫做：**笛卡尔积现象**
	- 为避免此现象，应该使用 `where` 条件限制，两表连接时，需要设定连接对应的字段（设定字段可以用 `表名.字段名` 避免冲突）
	- 表起别名：直接在表名后面加个空格（或 `as`）和别名，即可实现起别名。
	- 使用条件限制并不能减少比较次数，只是能够让显示的最终查询结果是准确的，因此需要减少连接次数来提高查询效率

## 内连接


### 等值连接


- `SQL92` 语法：
	- `select 表1.字段名1,...,表2.字段名k from 表1 表1的别名, 表2 表2的别名 where 表1.字段名i = 表2.字段名j`
	- 缺点：表的连接条件和筛选条件都放在 `where` 中导致结构不清晰

- `SQL99` 语法：
	- `select 表1.字段名1,...,表2.字段名k from 表1 表1的别名, 表2 表2的别名 (inner) join 表1, 表2 on 表1.字段名 where 表1.字段名i = 表2.字段名j` 
	- 后面可以继续加 `where` ，相比 `SQL92` 更清晰
	- `inner` 可省略


### 非等值连接

-  `on` 后的条件表达式为一个非等值的逻辑判断句（不要求字段值相等，而要求区间/其它表达式）


### 自连接

- 自己和自己连接，必须取不一样的别名
- 一张表看成两张表使用



## 外连接

- 内连接：完全能匹配条件的数据的才查询出来
- 外连接：将没匹配上的信息也查询出来，没匹配上的结果也要展示出来，将表对应数据全部显示出来，捎带关联查询 另一边的表。
	- `right (outer) join` 右外连接：将右边表没匹配上左边的查询的字段都显示出来
	- `left (outer) join` 左外连接，同理
	- `inner` 可省略
- 外连接中，表和表中产生了主次关系。
- 外连接查询结果条数 >= 内连接查询结果条数


## 三张表连接

- 语法：
```
select 
...
from 
a
join
b
on
a 和 b的连接条件
join
c
on
a 和 c的连接条件
join
d
on
a 和 d 的连接条件
...
```
- 一条 `SQL` 语句中，可以内连接和外连接混合使用

# Chap 11 子查询

- 子查询：`select` 语句中嵌套  `select` 语句，被嵌套的 `select` 语句称为子查询

- 位置：
```
select
	..(select).
from
	..(select).
where
	..(select).
```

## `where` 中的子查询

- `select ename, sal from emp where sal > (select min(sal) from emp);`


## `from` 中的子查询

- `from` 后面的子查询可以当作一张临时表
- 注意：起别名

## `select` 后的子查询

- 了解即可
- 缺陷，要求 `select` 语句中不能超过一条记录，不然和其它数据不是一一对应，不能形成一张表。



# Chap 12 `union`


## `union`

- 对于表连接来说，`union` 的效率相比先连接后查询效率更高（数据量更少）
- 注意事项：使用 `union` 进行结果集合并时，需要列的数据量和数据类型保持一致。


# Chap 13 `limit` 的使用

- `limit`：将查询结果集的一部分取出来，通常使用在分页查询中
- 为了提高用户的体验，一次全部都查出来，用户体验差，可以一页一页翻页看
- 语法：
	- 缺省用法：`select ... from ... where ... order by ... limit n` 取前n条记录
	- 通常和 `order by` 配合使用，取出前几位的数据，注意：需要在其之后
	- 完整用法：`limit m, n` 从第 `m` 条记录开始的 `n` 条记录
## 通用分页

- 百度显示数据，一页十条，我们也仿造此方式显示数据
- 假如：每页显示3条数据(`pageSize`)
	- 第1页：`limit 0,3`
	- 第2页：`limit 3,3`
	- 第`pageNo` 页： `limit (pageNo - 1) * pageSize, pageSize`
	- 上式为通用公式


## `DQL` 总结

格式：

```
select
	...
from
	...
where
	...
group by
	...
having      //过滤
	...
order by
	...
limit
	...
```

执行顺序：
- 1. `from`
- 2. `where`
- 3. `group by`
- 4. `having`  // 相当于 `group by` 中的 `where`
- 5. `select`
- 6. `order by`
- 7. `limit`

# Chap 14 表

## · DDL数据定义语言
### 创建语法  Create

- 建表属于 `DDL` （`create drop alter`）语句
- 语法：`create table 表名(字段名1 数据类型, 字段名1 数据类型);`
	- 表名：建议以 `t_` 或者 `tb1_` 开始，可读性强
	- 字段名：见名知意
	- 表名 和 字段名都属于标识符
	- 数据类型（常见）
		- `varchar`：可变长度的字符串，比较智能，节省空间，会根据数据长度动态分配空间；缺点就是需要动态分配空间，速度慢；最长255
		- `char`：定长字符串，不会改变数据存储长度，使用不恰当会导致空间浪费，但是效率比较高，最长255.
			- 二者的选择：已知范围的字段对应的数据类型可以选择 `char`，不确定的字段对应的数据类型可以选择 `varchar`
		- `int`：数字中的整数型，等同 `java` 中的 `int`，最长11位
		- `bigint`：数字中的长整型，等同于 `java` 中的 `long`，
		- `float`：单精度浮点型
		- `double`：双精度浮点型
		- `date`：短日期类型
		- `datatime`：长日期类型
		- `clob`：字符大对象，最多存储4G的字符串，超过255字节都需使用 `clob`字符大对象存储，是 `Character Large Object` 的缩写
		- `blob`：二进制大对象，`Binary Large Object`，专门用来存储图片、声音、视频等流媒体数据。使用 `IO` 流
- 语法（有默认值）
```
create table t_student(
	no int,
	name varchar(32),
	sex char(1) default 'm',
	age int(3),
	email varchar(255)
);
```

### 删除语法 Drop

- `drop table 表名` 即可实现删除表，当表不存在时会报错
	- `drop table if exists 表名` 

### 快速创建表

- 语法：`create table 表名1 as select * from 表名2;` //创建一个和表名2对应表相同的表。将 `select` 后的查询结果当作一张表

### 将查询结果插入到一张表中

- 语法：`insert into 表名1 select * from 表名2` 将从表名2对应的表的查询结果插入到表名1对应的表中。

### 快速删除表格数据

- 语法1：`delete from 表名`：删除表名对应的表的所有数据，删除速度比较慢；优点是支持回滚
- 语法2：`truncate` 语句删除数据的原理，删除效率高，物理删除，但是不支持回滚（恢复）


### 删除表

- 语法：`drop table 表名;`

### 对表结构进行修改

- 语法：`alter` 属于 `DDL`


## · 数据操纵语言 DML

### 插入数据 Insert

- 语法：`insert into 表名(字段名1, 字段名2, 字段名3,...) values(值1, 值2, 值3, ...)`
	- 字段名 和 值要一一对应，数量对应，数据类型对应
	- 注意： `insert` 语句但凡执行成功，必然会多一条记录。没有给其它字段指定值时，默认值是 `NULL`
	- 前面的字段名可省，省略的话，等于都写上了，值也必须写上。

- 插入日期
	- 数字格式化：`format(数字, '格式')`
	- 格式可以是：`$999,999`
	- `str_to_date`：必须严格按照标准输出，字符串 -> `date` 类型
		- `str_to_date('字符串日期', '日期格式')`
			- 格式：
				- `%Y` 年
				- `%M` 月
				- `%D` 日
				- `%H` 时
				- `%M` 分
				- `$S` 秒
	- `date_format`：`date`类型 -> `varchar`类型，展示数据类型
	- 如果向数据库中插入一个日期的格式是 `%Y-%M-%D`，则不需要 `str_to_date`，否则需要进行转换，不然会报错。

- 数据库有一条命名规范：所有的标识符都是全部小写，单词 和 单词之间使用下划线进行衔接

- `date` 和 `datetime` 两个类型的区别
	- 前者：短日期，只包括年月日
	- 后者：长日期，包括年月日时分秒

- `mysql` 中获取当前时间：`now()`

- `insert` 可以同时插入多条语句
```
insert into 表名(字段名1,..., 字段名k) values 
	(值1,..., 值k),
	(值1,..., 值k),
	...
	;
```

### 修改 `update`

- 语法格式
	- `update 表名 set 字段名1 = 值1, 字段名2 = 值2, 字段名3 = 值3... where 条件`

### 删除 `delete`

- 语法格式：
	- `delete from 表名 where 条件`
	- 没有条件，整张表都会删除


## 创建表加入约束(constraint)

### 约束定义

- 对数据字段加以约束，以保证插入时数据的完整性。
- 作用：保证表中数据有效

### 约束包括

- 非空约束：`not null`
- 唯一性约束：`unique`
- 主键约束：`primary key` （简称 `PK`）
- 外键约束：`foreign key` （简称 `FK`）
- 检查约束：`check` （`mysql`不支持，`oracle` 支持）

重点学习前四种

### 非空约束 `not null`

- 使用此约束的字段不能为 `null`

- `xxx.sql` 文件称为 `sql` 脚本文件
- `sql` 脚本文件中编写了大量的 `sql` 语句
- 执行 `sql` 脚本文件时，可以使用 `sql` 脚本语句
	- 执行语法：`source 路径...\路径...\xxx.sql`


### 唯一性约束 `unique`

- 使用此约束的字段不能重复
	- 但是可以为 `null`
- 如何让字段的组合具有唯一性
	- 语法：`create table 表名 (字段名1,...,字段名k unique(字段名i1, ..., 字段名ij)) values(值1, 值2, ... ,值k)`，单独添加到字段名后面称为列级约束，添加到最后为表级约束。
- 什么时候使用表级约束
	- 多个字段联合约束

### 主键约束 `primary key(PK)`

- 主键约束相关术语
	- 主键约束：一种约束
	- 主键字段：字段上添加了主键约束
	- 主键值：主键字段对应的值

- 主键：每一行记录的唯一标识
- 任何一张表都应该有主键，不然表是没效果的
- 主键约束后，插入数据不能为空 且 必须唯一
- 复合主键：将多个主键联合在一起进行表级约束
	- 一个主键：单一主键
	- 多个主键：多个主键
- 复合主键不建议使用，比较复杂
- 主键不能添加两个
- 不建议使用 `varchar` 来做主键值，主键值一般都是定长的

- 主键分类：
	- 单一主键、复合主键
	- 按照业务相关分类：
		- 自然主键：主键是一个自然数，和业务没关系
		- 业务主键：主键和业务紧密关联，例如拿银行账号做主键值
			- 自然主键更多，主键只要做到不重复就行
			- 业务主键不好，因为主键一旦和业务挂钩，当业务发生变动的时候，可能会影响到主键值。尽量使用自然主键

- `create table t_vip{id int primary auto_increment}` // `auto_increment` 表示自增，从1开始，以后每次插入新数据，对应主键（自然主键）就自增1


### 外键约束（foreign key, 简称 pk）


- 外键约束：一种约束
	- 出现在两个表进行连接时，连接的字段必须能定位到对应的表格属性

- 外键字段：该字段添加列外键约束
- 外键值：外键字段中的每一个值

- 设计数据库时，如果有一些数据会产生大量的重复，会产生数据冗余，空间浪费，这时候就需要将这部分数据分离出去

- 语法：`foreign key(cno) references t_class(classno)`

- 父表和子表
	- 父表：被引用的表，先创建，后删除，先插入
	- 子表：引用父表的表，后创建，先删除，后插入

- 子表引用父表的外键可以是主键嘛？
	- 不一定（因为可以是 null），但是必须具备 `unique` 约束

- 子表引用父表的外键可以是 `null` 嘛？
	- 可以


# Chap 15 存储引擎（了解）

- 存储引擎：存储引擎是 `MySQL` 特有的术语，是一个表存储/组织数据的方式，不同的存储引擎，表存储数据的方式不同。

- 如何给表添加/指定“存储引擎”
	- `show create table 表名`：可以在建表时指定建表引擎，在最后小括号的 ")" 的右边使用：
		- `ENGINE` 以指定存储引擎，`MySQL` 默认的存储引擎是 `InnoDB`
		- `CHARSET` 以指定表的字符编码方式，`MySQL` 默认的字符编码方式是 `utf-8`

- `MySQL` 支持哪些存储引擎：
	- 9大存储引擎，版本不同支持情况不同


## `MySQL` 常见的存储引擎（共9种）


- `MyISAM` 存储引擎
	- 管理的表有以下特征
		- 格式文件 - 存储表结构的定义
		- 数据文件 - 存储表行的内容
		- 索引文件 - 存储表上的索引：索引是一本书的目录，缩小扫描的范围，提高检索效率
		- 可被转换为 压缩、只读表来节省空间
		- 不支持事务，安全性低
		- 特点：可被转换为压缩、只读表节省空间（优势）


- `InnoDB` 存储引擎
	- `MySQL` 默认存储引擎，重量级存储引擎
	- 支持事务、数据库崩溃后自动回复机制
	- 非常安全
	- 每个 `InnoDB` 表 在数据库目录种以 `.frm` 格式文件表示
	- `InnoDB` 表空间 `tablespace` 被用于存储表的内容
	- 提供一组用来记录事务性活动的日志文件
	- 用 `COMMIT`(提交)、`SAVEPOINT` 以及 `ROLLBACK`(回滚) 支持事务处理
	- 提供 全`ACID` 兼容
	- 在 `MySQL` 服务器崩溃后提供自动恢复
	- 多版本 (`MVCC`) 和 行级锁定
	- 支持外键 基 引用的完整性，包括级联删除和更新
	- 因为支持事务，效率不高，且不能压缩，不能转换为只读，不能很好节省存储空间


- `MEMORY` 存储引擎 
	- 内存存储引擎，行的长度固定
	- 使得 `MEMORY` 引擎非常快
	- 特征
		- 在数据库目录中，每个表以 `.frm` 格式的文件表示
		- 表数据及索引被存储在内存中（目的是快）
		- 表级锁机制
		- 不能包含 `TEXT` 或 `BLOB` 字段
	- 被称为 `HEAP` 引擎
	- 优点：查询效率是最高的
	- 缺点：不安全，关机后数据消失，数据和索引都是内存当中

# Chap 16 事务

## 概述

- 事务：一个完整的业务逻辑。
- 完整的业务逻辑：例如，转账：将 `A` 账户 的钱减去 10000；将 `B` 账户的钱加上 10000
- 以上两种操作是最小的工作单元，要么同时成功，要么同时失败，才能保证钱是正确的。
- 只有 `DML` 语句才有事务一说，其它语句和事务无关
	- `insert`
	- `delete`
	- `update`
- 因为做某件事时，需要多条 `DML` 语句共同联合起来才能完成，所以需要事务存在，如果任何一个业务，都能用一个 `DML` 语句确定，则事务没有存在的价值了。
- 一个事务的本质：多条 `DML` 语句同时成功或同时失败

## 事务实现同时成功和同时失败

- `Innodb` 提供了一组用来记录事务性活动的日志文件
- 事务开启：`DML 语句1, DML 语句2, DML 语句3,...` 事务结束。
	- 每执行一次 `DML` ，都记录到 "事务性活动的日志文件" 中
- 事务执行过程中，可以提交事务，也可以回滚事务
	- 提交事务：提交事务活动的日志文件，将数据彻底持久化到数据库表中，标志事务的结束，全部成功的结束。
	- 回滚事务：将之前的 `DML` 操作全部撤销，清空事务性活动的日志文件，标志事务的结束，全部失败的结束。

## `Commit` 和 `Rollback`

- 提交事务 和 回滚事务
	- `commit`：提交事务后，回滚就无法生效了
	- `rollback`：回滚到上一次提交点
- `mysql` 中默认清空下是支持自动提交事务的，每执行一条 `DML` 语句就执行一次。但是这种自动提交事务不符合开发习惯的，一个业务通常需要多条 `DML` 共同执行
- 回滚只能回滚到上一次的提交点
- 执行 `start transaction` 即可实现对自动提交的禁用

## 事务特性

- A 原子性：事务是最小的工作单元，不可再分
- C 一致性：所有事物要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证事务的一致性
- I 隔离性：A事务 和 B事务之间具有一定的隔离，教室A 和 教室B 之间有一道墙，这个墙就是隔离性。A事务在操作一张表时，B事务也在操作一张表（多线程并发访问一张表）
- D 持久性：事务最终结束的一个保障，事务提交就是将没有保存到硬盘的数据保存到硬盘上去。

## 事务隔离级别

- 事务和事务的隔离级别
	- 读未提交：`read uncommitted` （最低的隔离级别）
		- 事务A 可以读取到 事务B未提交的数据
		- 存在的问题：读脏数据，A读取的数据，在之后被B修改了，数据不是正确的
		- 此类隔离级别一般是理论上的，大多数数据库的隔离级别是二级以上
	- 读已提交：`read committed`
		- 事务A只能读取到事务B提交之后的数据
		- 解决了脏读现象
		- 问题：不可重复读取数据，事务开启后，一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读取的事务是4条。（在处理事务的过程中，用户在读取数据，在事务开启和结束分别读取的数据量不同，3≠4），称为不可重复读取。
		- 这种隔离级别是比较真实的数据，每次读到的数据是绝对真实的数据
		- `Oracle` 默认的隔离级别是：`read commited`
	- 可重复读：`repeated read` 
		- 事务A开启之后，不管是多久，每一次在事务A读取的数据都是一致的，即使事务B将数据已经修改，并且提交了，事务A读取的数据都没有改变
		- 解决了不可重复读的问题
		- 存在的问题：出现幻影读，每一次读取到的数据都是幻想，不够真实
		- 只要事务不结束，读到的数据一致不发生改变
		- `MySQL` 默认的事务隔离级别就是：`repeated read`
		- 示例：银行统计总账，1：00开始统计，3点结束，如果1：00 - 3：00期间有人存钱，不会统计在内，银行统计的数据仅为1：00时刻对应的数据。
		- 本质：做了一个备份，读取的一直是备份数据
	- 序列化/串行化：`serializable`（最高的隔离级别）
		- 隔离级别最高，效率最低，解决了所有的问题
		- 表示事务排队，不能并发




# Chap 17 索引

## 索引的应用

- 索引：在数据库的字段上添加的，为了提高查询效率存在的一种机制
	- 单个或多个字段联合起来可以添加索引
	- 索引相当于目录，为了缩小扫描范围而存在的一种机制
	- 在 `mysql` 数据库当中索引也是需要排序的，并且这个索引的排序和 `TreeSet` 数据结构相同，`TreeSet`底层是一个自平衡的二叉树。`TreeSet(TreeMap)`底层是一个自平衡的二叉树，在 `mysql` 当中索引是一个 `B-Tree` 数据结构

- 在任何数据库中，主键会自动添加索引对象，`MySQL`会对`unique`约束的字段进行自动添加索引对象。
- 任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。
- `MySQL` 中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在 `MyISAM` 存储引擎中，索引存储在一个 `.MYI` 文件中；在 `InnoDB` 存储引擎中索引存储在一个逻辑名叫做 `tablespace` 的表当中；在 `MEMORY` 存储引擎当中索引存储在内存当中，不管索引存储在哪里，索引在 `mysql` 当中都是一个树的形式存在。（自平衡二叉树：B-Tree）


## 索引的原理

- 缩小扫描的范围，避免全表扫描
- `mysql` 中，会为 `unique` 字段 和 主键自动添加索引
- 什么条件会为字段添加索引？
	- 数据量庞大
	- 该字段经常出现在 `where` 后面，以条件的形式存在，即此字段经常被扫描
	- 该字段很少 `DML` 操作（`insert, delete, update`） 操作，因为 `DML` 之后，索引需要重新排序

## 索引的创建 和 删除

- 创建索引
	- 语法：`create index emp ename_index on emp(ename);
- 删除索引
	- 语法：`drop index emp ename_index on emp;` 删除 `emp` 表中 索引 `ename_index`
- 查看一个 `sql` 语句是否使用索引进行检索
	- 在 `sql` 语句中 前加入 `explain`

## 索引的失效

### 情况1

- 模糊匹配中以 `%` 开头会导致索引失效
	- 这是一种优化手段

### 情况2

- 使用 `or` 时会失效，如果使用 `or` 要求 `or` 两边的字段都要有索引，如果一边以上没有索引，则失效。因此不建议使用 `or`。

### 情况3

- 复合索引，没有使用左侧的列查找，索引失效

### 情况4

- 在 `where` 中索引列参加了运算，索引失效

### 情况5

- 在 `where` 当中索引列使用了函数（例如 `lower` 等）

## 索引的分类

- 索引是数据库进行优化的重要手段，优化的时候优先考虑的就是索引
- 索引的分类
	- 单一索引：一个字段上添加了索引
	- 复合索引：两个字段或更多的字段上添加了索引
	- 主键索引：主键上添加索引
	- 唯一性索引：具有 `unique` 约束的字段上添加索引
-  注意：唯一性比较弱的字段上添加索引用处不大，越唯一，效率越高


# Chap 18 视图（view）

- `view`：站在不同的角度看待同一份数据

- 视图对象的创建和删除
	- 创建：`create view 视图名 as select .. from 表名`
	- 删除：`drop view 视图名`
	- 更新：`update 视图名 set 字段名i1 = xxx where 字段名i2 = ...`
	- 注意：只有 `DQL` 语句才能以 `view` 形式创建

- 视图的作用
	- 面向视图对象进行crud，对视图的crud会导致原表发生改变。

- 视图对象在实际开发中的作用
	- 简化 `sql` 语句（等价于引用，起别名），利于维护复杂的 `sql` 语句

- 视图对象存在于硬盘之中，不会消失

# Chap 19 `DBA` 命令

- `DBA` 常用命令
	- 新建用户
		-  `CREATE USER username IDENTIFIED BY 'password'`
	- 授权
		- `grant all privilliges on dbname.tbname to 'username'@'log in ip' indetified by 'password'`
	- 回收权限 `revoke`
	- 导出导入(重点，数据的备份)
		- 数据的导出
			- Windows命令窗口：`mysql dump dbname> 路径:\库名.sql -u用户名 -p密码`
		- 数据导入
			- 首先，创建数据库：`create database 库名`
			- 然后使用数据库：`use 库名`
			- 最后初始化：
				- `source 路径:\库名.sql`

# Chap 20 数据库的三范式

- 数据库设计范式：数据库的涉及依据，如何进行数据库的设计
- 设置数据库表时，可按照三范式设计，避免数据冗余和空间浪费

## 第一范式

- 要求任何一张表必须有主键，每一个字段原子性，不可再分

## 第二范式

- 建立在第一范式的基础上
- 要求所有非主键字段所有非主键字段完全依赖主键，不要产生部分依赖（冗余 ）
- 多对多：三张表，关系表两个外键

## 第三范式

- 建立在第二范式的基础上
- 要求所有非主键字段直接依赖主键，不要产生传递依赖
- 一对多：多张表，多的表加外键

## 实际设计情况

- 有的时候会存在冗余，但是为了减少表的连接次数，这样做是合理的，对于开发人员来说， `sql` 语句的编写难度也会降低。



